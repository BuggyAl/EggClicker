on script load:
 
	set {_letters} to "Aa Bb Cc Dd Ee Ff Gg Hh Ii Jj Kk Ll Mm Nn Oo Pp Qq Rr Ss Tt Uu Vv Ww Xx Yy Zz"
	set {_letter-pairs::*} to {_letters} split at " "
 
	loop {_letter-pairs::*}:
 
		set {_pair::*} to loop-value split at ""
 
		set {_uppercase} to {_pair::1}
		set {_lowercase} to {_pair::2}
 
		set {letters::uppercase::%{_lowercase}%} to {_uppercase}
		set {letters::lowercase::%{_uppercase}%} to {_lowercase}
 
on script unload:
 
	delete {letters::*}
 

#function clientBlock(location: location, type: item, viewers: players):
 # set {_packet} to new play_server_block_change packet
 # set location pinfo 0 of {_packet} to {_location}
 # set "BlockData" pinfo 0 of {_packet} to {_type} # as seen on packetwrapper, this uses the blockdata pinfo
 # loop {_viewers::*}: #show peeps the new block
 #   send loop-value packet {_packet}

function switchCaseFor(text: text, to-uppercase: boolean) :: text:
 
	set {_characters::*} to {_text} split at ""
	set {_new} to ""
 
	loop {_characters::*}:
 
		set {_char} to loop-value
 
		if {_to-uppercase} is true:
			set {_char} to {letters::uppercase::%loop-value%}
		else:
			set {_char} to {letters::lowercase::%loop-value%}
 
		set {_new} to "%{_new}%%{_char}%"
 
	return {_new}
 
function uppercase(text: text) :: text:
 
	return switchCaseFor({_text}, true)
 
function lowercase(text: text) :: text:
 
	return switchCaseFor({_text}, false)
 
function capitalize(text: text) :: text:
 
	set {_char} to the first character of {_text}
	set {_char} to {letters::uppercase::%{_char}%}
 
	set {_remaining} to ""
	set {_remaining} to the last (length of {_text} - 1) characters of {_text}
 
	return "%{_char}%%{_remaining}%"
   
function getNumberFormatted(n: number) :: string:
	set {_l::*} to split "K,M,B,T,Qa,Qi,Sx,Sp,Oc,No,Dc,Ud,Dd,Td,Qad,Qid,Sxd,Spd,Ocd,Nod,Vg,Uvg,Dvg,Tvg,Qavg,Qivg,Sxvg,Spvg,Ocvg,Novg,Tg,Ut,Dt" at ","
	set {_i} to min(floor(log({_n})/3), size of {_l::*})
	return "%{_n}%" if {_i} <= 0
	set {_i2} to 1000^{_i}
	return "%{_n}/{_i2}%%{_l::%{_i}%}%"

command /testformatter <number>:
	permission: op
	trigger:
		send getNumberFormatted(arg-1) to player

function contains(list: objects, check: object) :: boolean:
	loop {%{_list}%::*}:
		if loop-value is {_check}:
			return true
	return false
	
command /viewregions:
	permission: op
	trigger:
		send "%{areas::clicker::*}%" to player
		send "Done!" to player

function resetPlayerAreas(p: player):
	set {_uuid} to uuid of {_p}
	set {%{_uuid}%::area::*} to false
	set {%{_uuid}%::area::eggclicker_spawn} to true
	add "library" to {_regs::*}
	add "bedroom" to {_regs::*}
	add "kitchen" to {_regs::*}
	add "cellar" to {_regs::*}
	add "backyard" to {_regs::*}
	add "mine" to {_regs::*}
	add "mine2" to {_regs::*}
	add "nether" to {_regs::*}
	add "stronghold" to {_regs::*}
	add "end" to {_regs::*}
	add "eggstreet" to {_regs::*}
	add "mcdonalds" to {_regs::*}
	add "hut" to {_regs::*}
	add "abandoned" to {_regs::*}
	add "skyscraper" to {_regs::*}
	add "beach" to {_regs::*}
	add "ship" to {_regs::*}
	add "lighthouse" to {_regs::*}
	add "graveyard" to {_regs::*}
	add "church" to {_regs::*}
	add "trainstation" to {_regs::*}
	replace all "," with "" in {_regs::*}
	loop {_regs::*}:
		execute console command "rg removemember eggclicker_%loop-value% %{_p}% -w EggClicker"
	clear {_regs::*}
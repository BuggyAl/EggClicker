on script load:
 
	set {_letters} to "Aa Bb Cc Dd Ee Ff Gg Hh Ii Jj Kk Ll Mm Nn Oo Pp Qq Rr Ss Tt Uu Vv Ww Xx Yy Zz"
	set {_letter-pairs::*} to {_letters} split at " "
 
	loop {_letter-pairs::*}:
 
		set {_pair::*} to loop-value split at ""
 
		set {_uppercase} to {_pair::1}
		set {_lowercase} to {_pair::2}
 
		set {letters::uppercase::%{_lowercase}%} to {_uppercase}
		set {letters::lowercase::%{_uppercase}%} to {_lowercase}
 
on script unload:
 
	delete {letters::*}
 

#function clientBlock(location: location, type: item, viewers: players):
 # set {_packet} to new play_server_block_change packet
 # set location pinfo 0 of {_packet} to {_location}
 # set "BlockData" pinfo 0 of {_packet} to {_type} # as seen on packetwrapper, this uses the blockdata pinfo
 # loop {_viewers::*}: #show peeps the new block
 #   send loop-value packet {_packet}

function switchCaseFor(text: text, to-uppercase: boolean) :: text:
 
	set {_characters::*} to {_text} split at ""
	set {_new} to ""
 
	loop {_characters::*}:
 
		set {_char} to loop-value
 
		if {_to-uppercase} is true:
			set {_char} to {letters::uppercase::%loop-value%}
		else:
			set {_char} to {letters::lowercase::%loop-value%}
 
		set {_new} to "%{_new}%%{_char}%"
 
	return {_new}
 
function uppercase(text: text) :: text:
 
	return switchCaseFor({_text}, true)
 
function lowercase(text: text) :: text:
 
	return switchCaseFor({_text}, false)
 
function capitalize(text: text) :: text:
 
	set {_char} to the first character of {_text}
	set {_char} to {letters::uppercase::%{_char}%}
 
	set {_remaining} to ""
	set {_remaining} to the last (length of {_text} - 1) characters of {_text}
 
	return "%{_char}%%{_remaining}%"

#function getNumberFormatted(n: number) :: text:
#    set {_symbols::*} to "", "K", "M", "B", "T", "QD", "QN", "SX", "SP", "OC", "N", "D", "UN","DD","TR" and "QN"
#    set {_i} to 1
#    set {_v} to {_n}
#    while ({_v} / 1000) > 1:
#        set {_v} to {_v} / 1000
#        add 1 to {_i}
#    set {_s} to {_symbols::%{_i}%} ? ""
#    broadcast "{_s}: %{_s}%"
#    return "%{_v}%%{_s}%"
   
function getNumberFormatted(n: number) :: text:
	set {_data} to "QT,18|Q,15|T,12|B,9|M,6|k,3"
	loop split {_data} at "|":
		set {_s::*} to split loop-value at ","
		{_n} >= 10 ^ {_s::2} parsed as number
		return "%{_n} / 10 ^ {_s::2} parsed as number%%{_s::1}%"
	return "%{_n}%"
   
function newFormatNum(n: number) :: string:
	set {_l::*} to split "k,M,B,T,Qn,Qi,Sx" at ","
	set {_i} to min(floor(log({_n})/3), size of {_l::*})
	return "%{_n}%" if {_i} <= 0
	set {_i2} to 1000^{_i}
	return "%{_n}/{_i2}%%{_l::%{_i}%}%"

command /testnewformatter <number>:
	permission: op
	trigger:
		send newFormatNum(arg-1) to player

function contains(list: objects, check: object) :: boolean:
	loop {%{_list}%::*}:
		if loop-value is {_check}:
			return true
	return false
	
  
  
function print(t: text):
	send "%{_t}%" to all players